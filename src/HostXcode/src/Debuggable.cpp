#include "Debuggable.h"

#include "DebugWindow.h"

#include "imgui.h"

#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/DenseSet.h"

#include "IntervalTree.h"

#include <cxxabi.h>
#include <malloc/malloc.h>

#include <format>
#include <unordered_map>

namespace lldb::imgui {

/// `Debuggable` should be an empty class, so there is not ABI difference when debugging support is turned off
static_assert(std::is_empty_v<Debuggable<std::string>>);

/// Canonical registry for `Debuggable` instances
class Debuggables final : public Registry<DebuggableTag> {
    Debuggables() = default;

public:
    static Debuggables& GetInstance() {
        static Debuggables instance;
        return instance;
    }

    using ID = uint64_t;
    using Range = std::pair<uintptr_t, uintptr_t>;

    static Range MakeRange(void* addr, size_t size) {
        auto start = reinterpret_cast<uintptr_t>(addr);

        return std::make_pair(start, start + size - 1);
    }

    ID _nextID = 1;

    /// Range of memory to Debuggable's ID
    llvm::DenseMap<Range, ID> _ranges;

    struct TypeInfo {
        std::string name;
        Invoker invoker;

        TypeInfo(Invoker invoker, const std::type_info& tinfo)
        : invoker(invoker) {
            size_t len;
            int status;

            char* buffer = abi::__cxa_demangle(tinfo.name(), nullptr, &len, &status);
            if (status != 0) {
                name.assign(tinfo.name());
            } else {
                name.assign(buffer, len);
            }
            free(buffer);
        }
    };
    std::unordered_map<Invoker, TypeInfo> _typeInfos;

    struct Entry {
        uintptr_t startAddr;

        /// Type information describing the debuggable
        TypeInfo& typeInfo;

        /// User facing label - autogenerated, can be customized
        std::string customLabel;

        /// Containment relationships
        ID container = 0;
        llvm::SmallVector<ID> contains;

        /// Pointer relationships
        llvm::SmallDenseSet<ID> referrers;
        llvm::SmallDenseSet<ID> referenced;

        Entry(uintptr_t startAddr, TypeInfo& typeInfo)
        : startAddr(startAddr)
        , typeInfo(typeInfo)
        {}
    };
    std::unordered_map<ID, Entry> _debuggables;

    /// Orphaned Debuggables, which we failed to find any container/referrers
    llvm::DenseSet<ID> _orphans;

    /// Newly added Debuggables which necessitate rebuilding connectivity
    llvm::DenseSet<ID> _dirty;

    void Register(Range range, Invoker invoker, const std::type_info& tinfo);
    void Unregister(Range range);

    void Draw();

private:
    void BuildConnectivity();

    void DrawEntry(ID id);
};

void Debuggables::Register(Range range, Invoker invoker, const std::type_info& tinfo) {
    auto& typeInfo = _typeInfos.try_emplace(invoker, invoker, tinfo).first->second;

    auto [it, added] = _ranges.try_emplace(range, _nextID);
    if (!added) {
        assert(false);
        return;
    }

    _debuggables.try_emplace(_nextID, range.first, typeInfo);
    _dirty.insert(_nextID);

    _nextID++;
}

void Debuggables::Unregister(Range range) {
    ID deadID;
    {
        auto it = _ranges.find(range);
        if (it == _ranges.end()) {
            assert(false);
            return;
        }

        deadID = it->second;
        _ranges.erase(it);
    }

    auto node = _debuggables.extract(deadID);

    // Detach connections
    Entry& entry = node.mapped();

    for (ID id : entry.contains) {
        Entry& child = _debuggables.at(id);

        child.container = 0;

        if (child.referrers.empty()) {
            _orphans.insert(id);
        }
    }
    for (ID id : entry.referenced) {
        Entry& referenced = _debuggables.at(id);

        referenced.referrers.erase(deadID);

        if (referenced.referrers.empty() && referenced.container == 0) {
            _orphans.insert(id);
        }
    }
    for (ID id : entry.referrers) {
        Entry& referrer = _debuggables.at(id);

        referrer.referenced.erase(deadID);
    }

    _orphans.erase(deadID);
    _dirty.erase(deadID);
}

void Debuggables::BuildConnectivity() {
    // Reset connectivity
    for (auto& [_, entry] : _debuggables) {
        entry.container = 0;
        entry.contains.clear();

        entry.referrers.clear();
        entry.referenced.clear();
    }

    // Build interval tree of all debuggable objects
    IntervalTree<uintptr_t, ID> tree;
    {
        std::vector<Interval<uintptr_t, ID>> intervals;

        for (auto& [range, id] : _ranges) {
            intervals.emplace_back(range.first, range.second, id);
        }
        tree = IntervalTree(std::move(intervals));
    }

    // Build static connectivity - schedule memory scans from roots
    struct Scan {
        Range range;
        ID id;
        Entry* entry;
    };
    std::vector<Scan> scans;

    for (auto& [range, id] : _ranges) {
        Entry& entry = _debuggables.at(id);

        auto kMaxSize = std::numeric_limits<uintptr_t>::max();

        // Start with a very bad candidate for the container
        Range container(0, kMaxSize);

        // Keep testing intervals overlapping startAddr - the smaller the interval the better
        for (auto candidate : tree.findOverlapping(range.first, range.second)) {
            if (candidate.start < container.first) {
                continue; // Worse than current candidate
            }
            if (container.second < candidate.stop) {
                continue; // Worse than current candidate
            }
            if (candidate.stop < range.second) {
                continue; // Does not encapsulate child
            }
            if (candidate.start == range.first && candidate.stop == range.second) {
                continue; // This is the child itself
            }

            container.first = candidate.start;
            container.second = candidate.stop;
        }

        auto it = _ranges.find(container);
        if (it == _ranges.end()) {
            scans.emplace_back(Scan{
                .range = range,
                .id = id,
                .entry = &entry,
            });
            continue;
        }

        entry.container = it->second;
        _debuggables.at(entry.container).contains.push_back(id);
    }

    // Build dynamic connectivity
    std::function<void(Range, ID, Entry&, int)> doScan = [&](Range range, ID rid, Entry& rentry, int depth) {
        uintptr_t cursor = range.first;
        uintptr_t cursorMax = range.second;

        if (auto offset = cursor % sizeof(void*)) {
            cursor += sizeof(void*) - offset;
        }

        for (; cursor < cursorMax; cursor += sizeof(void*)) {
            uintptr_t startAddr = *reinterpret_cast<uintptr_t*>(cursor);

            if (startAddr < 4096) {
                continue; // Zeropage pointer
            }
            if (!malloc_zone_from_ptr((void*) startAddr)) {
                continue; // Not malloc'd
            }
            uintptr_t endAddr = startAddr + malloc_size((void*) startAddr);

            // Flag everything without a container in the malloc'd area as referenced
            bool foundSome = false;

            for (auto range : tree.findOverlapping(startAddr, endAddr)) {
                Entry& entry = _debuggables.at(range.value);

                if (entry.container != 0) {
                    continue;
                }

                entry.referrers.insert(rid);
                rentry.referenced.insert(range.value);
                foundSome = true;
            }
            if (foundSome || depth > 2) {
                continue;
            }

            doScan(Range(startAddr, endAddr), rid, rentry, depth + 1);
        }
    };
    for (Scan& scan : scans) {
        doScan(scan.range, scan.id, *scan.entry, 0);
    }

    for (Scan& scan : scans) {
        if (scan.entry->referrers.empty()) {
            _orphans.insert(scan.id);
        }
    }

    _dirty.clear();
}

void Debuggables::Draw() {
    using namespace ImGui;

    BuildConnectivity();

    if (_debuggables.empty()) {
        TextDisabled("No Debuggable instances");
        return;
    }

    for (ID id : _orphans) {
        DrawEntry(id);
    }
}

void Debuggables::DrawEntry(ID id) {
    using namespace ImGui;

    Entry& entry = _debuggables.at(id);

    bool isOpen;

    if (entry.customLabel.empty()) {
        isOpen = TreeNode((void*) id, "0x%016lx %s", entry.startAddr, entry.typeInfo.name.c_str());
    } else {
        isOpen = TreeNode((void*) id, "0x%016lx %s", entry.startAddr, entry.customLabel.c_str());
    }

    if (isOpen) {
        for (ID child : entry.contains) {
            DrawEntry(child);
        }
        for (ID referenced : entry.referenced) {
            DrawEntry(referenced);
        }
        TreePop();
    }
}

class DebuggablesWindow : public DebugWindow {
    void Init(State& state) override {
        state.title = "Debuggables";
    }
    void Draw() override {
        Debuggables::GetInstance().Draw();
    }
} g_debuggablesWindow;

Registry<DebuggableTag>& Registry<DebuggableTag>::Default() {
    return Debuggables::GetInstance();
}

void Registry<DebuggableTag>::Register(void* derived, size_t size, Invoker invoker, const std::type_info& tinfo) {
    Debuggables::GetInstance().Register(Debuggables::MakeRange(derived, size), invoker, tinfo);
}

void Registry<DebuggableTag>::Unregister(void* derived, size_t size) {
    Debuggables::GetInstance().Unregister(Debuggables::MakeRange(derived, size));
}

void Registry<DebuggableTag>::SetParent(void* derived, size_t size, void* parent, size_t psize) {
    // NOOP
}

void Registry<DebuggableTag>::SetLabel(void* derived, size_t size, std::string_view label) {
    auto& instance = Debuggables::GetInstance();

    auto it = instance._ranges.find(Debuggables::MakeRange(derived, size));
    if (it == instance._ranges.end()) {
        assert(false);
        return;
    }

    instance._debuggables.at(it->second).customLabel = label;
}

}
